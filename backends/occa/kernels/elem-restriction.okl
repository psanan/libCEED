// Copyright (c) 2019, Lawrence Livermore National Security, LLC.
// Produced at the Lawrence Livermore National Laboratory. LLNL-CODE-734707.
// All Rights reserved. See files LICENSE and NOTICE for details.
//
// This file is part of CEED, a collection of benchmarks, miniapps, software
// libraries and APIs for efficient high-order finite element and spectral
// element discretizations for exascale applications. For more information and
// source code availability see http://github.com/ceed.
//
// The CEED research is supported by the Exascale Computing Project 17-SC-20-SC,
// a collaborative effort of two U.S. Department of Energy organizations (Office
// of Science and the National Nuclear Security Administration) responsible for
// the planning and preparation of a capable exascale ecosystem, including
// software, applications, hardware, advanced system engineering and early
// testbed platforms, in support of the nation's exascale computing imperative.

#ifndef CEED_OCCA_KERNELS_ELEMRESTRICTION_HEADER
#define CEED_OCCA_KERNELS_ELEMRESTRICTION_HEADER

#include "./kernel-defines.hpp"

// Kernels are based on the cuda backend from LLNL and VT groups
//
// Expects the following types to be defined:
// - CeedInt
// - CeedScalar
//
// Expects the following constants to be defined:
// - COMPONENT_COUNT    : CeedInt
// - ELEMENT_SIZE       : CeedInt
// - NODE_COUNT         : CeedInt
// - TILE_SIZE          : int
// - BLOCK_SIZE         : int     (applyBlocked)
// - USES_INDICES       : bool
// - COMP_IS_FAST_INDEX : bool

static std::string elemRestriction_source = STRINGIFY_SOURCE(

@kernel
void applyWithoutRTranspose(const CeedInt elementCount,
                            @restrict const CeedInt *indices,
                            @restrict const CeedScalar *u,
                            @restrict CeedScalar *v) {
  @tile(TILE_SIZE, @outer, @inner)
  for (int n = 0; n < (elementCount * ELEMENT_SIZE); ++n) {
@directive("#if USES_INDICES")
    const CeedInt uOffset = indices[n];
@directive("#else")
    const CeedInt uOffset = n;
@directive("#endif")

    const CeedInt vOffset = (
      // Element offset
      (n / ELEMENT_SIZE) * (ELEMENT_SIZE * COMPONENT_COUNT)
      // Node offset
      + (n % ELEMENT_SIZE)
    );

    for (int c = 0; c < COMPONENT_COUNT; ++c) {
@directive("#if COMP_IS_FAST_INDEX")
      v[vOffset + (c * ELEMENT_SIZE)] = u[c + (uOffset * COMPONENT_COUNT)];
@directive("#else")
      v[vOffset + (c * ELEMENT_SIZE)] = u[uOffset + (c * NODE_COUNT)];
@directive("#endif")
    }
  }
}

@kernel
void applyWithRTranspose(@restrict const CeedInt *offsets,
                         @restrict const CeedInt *indices,
                         @restrict const CeedScalar *u,
                         @restrict CeedScalar *v) {
  @tile(TILE_SIZE, @outer, @inner)
  for (int n = 0; n < NODE_COUNT; ++n) {
    CeedScalar vComp[COMPONENT_COUNT];

    const CeedInt offsetStart = offsets[n];
    const CeedInt offsetEnd = offsets[n + 1];

    for (int c = 0; c < COMPONENT_COUNT; ++c) {
      vComp[c] = 0;
    }

    for (CeedInt i = offsetStart; i < offsetEnd; ++i) {
      const CeedInt index = indices[i];

      const CeedInt uOffset = (
        // Element offset
@directive("#if COMP_IS_FAST_INDEX")
        ((index / ELEMENT_SIZE) * (ELEMENT_SIZE * COMPONENT_COUNT))
@directive("#else")
        ((index / ELEMENT_SIZE) * ELEMENT_SIZE)
@directive("#endif")
        // Node offset
        + (index % ELEMENT_SIZE)
      );

      for (int c = 0; c < COMPONENT_COUNT; ++c) {
@directive("#if COMP_IS_FAST_INDEX")
        vComp[c] += u[c + (uOffset * COMPONENT_COUNT)];
@directive("#else")
        vComp[c] += u[uOffset + (c * ELEMENT_SIZE)];
@directive("#endif")
      }
    }

    for (int c = 0; c < COMPONENT_COUNT; ++c) {
      v[n + (c * NODE_COUNT)] += vComp[c];
    }
  }
}

);

static std::string elemRestrictionBlockedFunctions_source = STRINGIFY_SOURCE(

inline void applyElementWithoutRTranspose(const CeedInt element,
                                          @restrict const CeedInt *indices,
                                          @restrict const CeedScalar *u,
                                          @restrict CeedScalar *v) {
  for (int n = 0; n < ELEMENT_SIZE; ++n) {
@directive("#if USES_INDICES")
    const CeedInt uOffset = indices[(element * ELEMENT_SIZE) + n];
@directive("#else")
    const CeedInt uOffset = (element * ELEMENT_SIZE) + n;
@directive("#endif")

    const CeedInt vOffset = (
      // Element offset
      element * (ELEMENT_SIZE * COMPONENT_COUNT)
      // Node offset
      + n
    );

    for (int c = 0; c < COMPONENT_COUNT; ++c) {
@directive("#if COMP_IS_FAST_INDEX")
      v[vOffset + (c * ELEMENT_SIZE)] = u[c + (uOffset * COMPONENT_COUNT)];
@directive("#else")
      v[vOffset + (c * ELEMENT_SIZE)] = u[uOffset + (c * NODE_COUNT)];
@directive("#endif")
    }
  }
}

inline void applyElementWithRTranspose(const CeedInt blockElement,
                                       const CeedInt element,
                                       @restrict const CeedScalar *u,
                                       @restrict CeedScalar *v) {
  for (int n = 0; n < ELEMENT_SIZE; ++n) {
    const int uOffset = (
      // Node offset
      (n * BLOCK_SIZE)
      // Element offset
      + blockElement
    );

    const int vOffset = (
      (element * COMPONENT_COUNT * ELEMENT_SIZE) + n
    );

    for (int c = 0; c < COMPONENT_COUNT; ++c) {
@directive("#if COMP_IS_FAST_INDEX")
      v[c + (vOffset * COMPONENT_COUNT)] += u[uOffset + (c * ELEMENT_SIZE * BLOCK_SIZE)];
@directive("#else")
      v[vOffset + (c * NODE_COUNT)] += u[uOffset + (c * ELEMENT_SIZE * BLOCK_SIZE)];
@directive("#endif")
    }
  }
}

inline void applyElementWithRTransposeWithIndices(const CeedInt blockElement,
                                                  const CeedInt element,
                                                  @restrict const CeedInt *uOffsets,
                                                  @restrict const CeedInt *vOffsets,
                                                  @restrict const CeedInt *uIndices,
                                                  @restrict const CeedInt *vIndices,
                                                  @restrict const CeedScalar *u,
                                                  @restrict CeedScalar *v) {
  /*
    v[5] += u[0]
    v[6] += u[1]
    v[6] += u[5]
    v[7] += u[2]
    v[7] += u[6]
    v[8] += u[7]
  */

  const CeedInt vOffsetStart = vOffsets[element];
  const CeedInt vOffsetEnd = vOffsets[element + 1];

  for (int vi = vOffsetStart; vi < vOffsetEnd; ++vi) {
    CeedScalar vComp[COMPONENT_COUNT];

    const CeedInt vIndex = vIndices[vi];

    const CeedInt uOffsetStart = uOffsets[vi];
    const CeedInt uOffsetEnd = uOffsets[vi + 1];

    for (int c = 0; c < COMPONENT_COUNT; ++c) {
      vComp[c] = 0;
    }

    for (int ui = uOffsetStart; ui < uOffsetEnd; ++ui) {
      const CeedInt uIndex = uIndices[ui];

      for (int c = 0; c < COMPONENT_COUNT; ++c) {
        vComp[c] += u[uIndex + (c * ELEMENT_SIZE * BLOCK_SIZE)];
      }
    }

    for (int c = 0; c < COMPONENT_COUNT; ++c) {
@directive("#if COMP_IS_FAST_INDEX")
      v[c + (vIndex * COMPONENT_COUNT)] += vComp[c];
@directive("#else")
      v[vIndex + (c * NODE_COUNT)] += vComp[c];
@directive("#endif")
    }
  }
}

);

static std::string elemRestrictionBlocked_source = (
  elemRestrictionBlockedFunctions_source
  + "\n"
  + STRINGIFY_SOURCE(

@kernel
void applyWithoutRTranspose(const int firstElement,
                            const int lastElement,
                            @restrict const CeedInt *indices,
                            @restrict const CeedScalar *u,
                            @restrict CeedScalar *v) {
  @tile(BLOCK_SIZE, @outer, @inner)
  for (int e = firstElement; e < lastElement; ++e) {
    const int block = (e / BLOCK_SIZE) * BLOCK_SIZE;
    const int blockOffset = block * ELEMENT_SIZE * COMPONENT_COUNT;
    applyElementWithoutRTranspose(e, indices, u, v - blockOffset);
  }
}

@kernel
void applyWithRTranspose(const int firstElement,
                         const int lastElement,
                         @restrict const CeedInt *uOffsets,
                         @restrict const CeedInt *vOffsets,
                         @restrict const CeedInt *uIndices,
                         @restrict const CeedInt *vIndices,
                         @restrict const CeedScalar *u,
                         @restrict CeedScalar *v) {
  @tile(BLOCK_SIZE, @outer, @inner)
  for (int e = firstElement; e < lastElement; ++e) {
@directive("#if USES_INDICES")
    applyElementWithRTransposeWithIndices(e - firstElement,
                                          e,
                                          uOffsets,
                                          vOffsets,
                                          uIndices,
                                          vIndices,
                                          u,
                                          v);
@directive("#else")
    applyElementWithRTranspose(e,
                               e - firstElement,
                               u,
                               v);
@directive("#endif")
  }
}

));

#endif
