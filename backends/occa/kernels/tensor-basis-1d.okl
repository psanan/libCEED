// Based on cuda-shared kernels
//
// Expects the following types:
// - CeedInt
// - CeedScalar
//
// Expects the following definitions:
// - Q1D                  : CeedInt
// - P1D                  : CeedInt
// - ELEMENTS_PER_BLOCK   : CeedInt
// - BASIS_COMPONENT_COUNT: CeedInt

#define SHARED_BUFFER_SIZE (Q1D * ELEMENTS_PER_BLOCK)

typedef CeedScalar* sharedBufferArray  @dim(Q1D, ELEMENTS_PER_BLOCK);
typedef CeedScalar* batchedDofArray    @dim(P1D, BASIS_COMPONENT_COUNT, elementCount);
typedef CeedScalar* batchedQuadArray   @dim(Q1D, elementCount, BASIS_COMPONENT_COUNT);
typedef CeedScalar* dofToQuadMap       @dim(P1D, Q1D);
typedef CeedScalar* elementWeightArray @dim(Q1D, elementCount);


//---[ Utility Methods ]----------------
inline void readDofs(const int element,
                     const int localElement,
                     const int component,
                     const int p,
                     const batchedDofArray U,
                     sharedBufferArray sharedBuffer) {
  // Zero out extra entries
  sharedBuffer(p, localElement) = (
    (p < P1D)
    ? U(p, component, element)
    : 0.0
  );
}

inline void writeDofs(const int element,
                      const int component,
                      const int p,
                      const CeedScalar Vp,
                      batchedDofArray V) {
  if (p < P1D) {
    V(p, component, element) = Vp;
  }
}

inline void readQuads(const int elementCount,
                      const int element,
                      const int localElement,
                      const int component,
                      const int q,
                      batchedQuadArray U,
                      sharedBufferArray sharedBuffer) {
  sharedBuffer(q, localElement) = U(q, element, component);
}

inline void writeQuads(const int elementCount,
                       const int element,
                       const int component,
                       const int q,
                       batchedQuadArray V,
                       const CeedScalar Vq) {
  V(q, element, component) = Vq;
}

inline void contractX(const int q,
                      const int localElement,
                      sharedBufferArray sharedBuffer,
                      const dofToQuadMap B,
                      CeedScalar &V) {
  V = 0.0;
  for (int p = 0; p < P1D; ++p) {
    V += B(p, q) * sharedBuffer(p, localElement);
  }
}

inline void contractTransposeX(const int p,
                               const int localElement,
                               sharedBufferArray sharedBuffer,
                               const dofToQuadMap B,
                               CeedScalar &V) {
  V = 0.0;
  for (int q = 0; q < Q1D; ++q) {
    V += B(p, q) * sharedBuffer(q, localElement);
  }
}

//---[ Kernels ]------------------------
@kernel void interp(const CeedInt elementCount,
                    const int transpose,
                    @restrict const CeedScalar *B,
                    @restrict const CeedScalar *U,
                    @restrict CeedScalar *V) {

  for (int elementOffset = 0; elementOffset < elementCount; elementOffset += ELEMENTS_PER_BLOCK; @outer) {
    @shared CeedScalar sharedBuffer[SHARED_BUFFER_SIZE];

    for (int localElement = 0; localElement < ELEMENTS_PER_BLOCK; ++localElement; @inner) {
      for (int q = 0; q < Q1D; ++q; @inner) {

        const int element = elementOffset + localElement;
        if (element < elementCount) {
          for(int component = 0; component < BASIS_COMPONENT_COUNT; ++component) {
            if(!transpose) {
              CeedScalar Vq;
              readDofs(element, localElement, component, q, U, sharedBuffer);
              contractX(q, localElement, sharedBuffer, B, Vq);
              writeQuads(elementCount, element, component, q, V, Vq);
            } else {
              CeedScalar Vp;
              readQuads(elementCount, element, localElement, component, q, U, sharedBuffer);
              contractTransposeX(q, localElement, sharedBuffer, B, Vp);
              writeDofs(element, component, q, Vp, V);
            }
          }
        }

      }
    }
  }
}

@kernel void grad(const CeedInt elementCount,
                  const int transpose,
                  @restrict const CeedScalar *G,
                  @restrict const CeedScalar *U,
                  @restrict CeedScalar *V) {

  for (int elementOffset = 0; elementOffset < elementCount; elementOffset += ELEMENTS_PER_BLOCK; @outer) {
    @shared CeedScalar sharedBuffer[SHARED_BUFFER_SIZE];

    for (int localElement = 0; localElement < ELEMENTS_PER_BLOCK; ++localElement; @inner) {
      for (int q = 0; q < Q1D; ++q; @inner) {

        const int element = elementOffset + localElement;
        if (element < elementCount) {
          for(int component = 0; component < BASIS_COMPONENT_COUNT; ++component) {
            if(!transpose) {
              CeedScalar Vq;
              readDofs(element, localElement, component, q, U, sharedBuffer);
              contractX(q, localElement, sharedBuffer, G, Vq);
              writeQuads(elementCount, element, component, q, V, Vq);
            } else {
              CeedScalar Vp;
              readQuads(elementCount, element, localElement, component, q, U, sharedBuffer);
              contractTransposeX(q, localElement, sharedBuffer, G, Vp);
              writeDofs(element, component, q, Vp, V);
            }
          }
        }

      }
    }
  }
}

@kernel weight(const CeedInt elementCount,
               @retrict const CeedScalar *qWeights1D,
               @retrict elementWeightArray W) {
  for (int elementOffset = 0; elementOffset < elementCount; elementOffset += ELEMENTS_PER_BLOCK; @outer) {
    for (int element = elementOffset; element < (elementOffset + ELEMENTS_PER_BLOCK); ++element; @outer) {
      for (int q = 0; q < Q1D; ++q; @inner) {
        W(q, element) = qWeights1D[q];
      }
    }
  }
}
