// Copyright (c) 2019, Lawrence Livermore National Security, LLC.
// Produced at the Lawrence Livermore National Laboratory. LLNL-CODE-734707.
// All Rights reserved. See files LICENSE and NOTICE for details.
//
// This file is part of CEED, a collection of benchmarks, miniapps, software
// libraries and APIs for efficient high-order finite element and spectral
// element discretizations for exascale applications. For more information and
// source code availability see http://github.com/ceed.
//
// The CEED research is supported by the Exascale Computing Project 17-SC-20-SC,
// a collaborative effort of two U.S. Department of Energy organizations (Office
// of Science and the National Nuclear Security Administration) responsible for
// the planning and preparation of a capable exascale ecosystem, including
// software, applications, hardware, advanced system engineering and early
// testbed platforms, in support of the nation's exascale computing imperative.

#ifndef CEED_OCCA_KERNELS_TENSORBASIS1D_HEADER
#define CEED_OCCA_KERNELS_TENSORBASIS1D_HEADER

#include "header.hpp"


static const char *tensorBasis1DSource = STRINGIFY_SOURCE(

typedef CeedScalar* sharedBufferArray  @dim(Q1D, ELEMENTS_PER_BLOCK);
typedef CeedScalar* batchedDofArray    @dim(P1D, BASIS_COMPONENT_COUNT, elementCount);
typedef CeedScalar* batchedQuadArray   @dim(Q1D, elementCount, BASIS_COMPONENT_COUNT);
typedef CeedScalar* dofToQuadMap       @dim(P1D, Q1D);
typedef CeedScalar* elementWeightArray @dim(Q1D, elementCount);


//---[ Utility Methods ]----------------
inline void readDofs(const int element,
                     const int localElement,
                     const int component,
                     const int p,
                     const batchedDofArray U,
                     sharedBufferArray sharedBuffer) {
  // Zero out extra entries
  sharedBuffer(p, localElement) = (
    (p < P1D)
    ? U(p, component, element)
    : 0.0
  );
}

inline void writeDofs(const int element,
                      const int component,
                      const int p,
                      const CeedScalar Vp,
                      batchedDofArray V) {
  if (p < P1D) {
    V(p, component, element) = Vp;
  }
}

inline void readQuads(const int elementCount,
                      const int element,
                      const int localElement,
                      const int component,
                      const int q,
                      batchedQuadArray U,
                      sharedBufferArray sharedBuffer) {
  sharedBuffer(q, localElement) = U(q, element, component);
}

inline void writeQuads(const int elementCount,
                       const int element,
                       const int component,
                       const int q,
                       const CeedScalar Vq,
                       batchedQuadArray V) {
  V(q, element, component) = Vq;
}

inline void contractX(const int q,
                      const int localElement,
                      sharedBufferArray sharedBuffer,
                      const dofToQuadMap B,
                      CeedScalar &V) {
  V = 0.0;
  for (int p = 0; p < P1D; ++p) {
    V += B(p, q) * sharedBuffer(p, localElement);
  }
}

inline void contractTransposeX(const int p,
                               const int localElement,
                               sharedBufferArray sharedBuffer,
                               const dofToQuadMap B,
                               CeedScalar &V) {
  V = 0.0;
  for (int q = 0; q < Q1D; ++q) {
    V += B(p, q) * sharedBuffer(q, localElement);
  }
}

//---[ Kernels ]------------------------
@kernel void interp(const CeedInt elementCount,
                    const bool transpose,
                    @restrict const CeedScalar *B,
                    @restrict const CeedScalar *U,
                    @restrict CeedScalar *V) {

  for (int elementOffset = 0; elementOffset < elementCount; elementOffset += ELEMENTS_PER_BLOCK; @outer) {
    @shared CeedScalar sharedBuffer[SHARED_BUFFER_SIZE];

    for (int localElement = 0; localElement < ELEMENTS_PER_BLOCK; ++localElement; @inner) {
      for (int q = 0; q < Q1D; ++q; @inner) {

        const int element = elementOffset + localElement;
        if (element < elementCount) {
          for (int component = 0; component < BASIS_COMPONENT_COUNT; ++component) {
            CeedScalar Vq;
            if (!transpose) {
              readDofs(element, localElement, component, q, U, sharedBuffer);
              contractX(q, localElement, sharedBuffer, B, Vq);
              writeQuads(elementCount, element, component, q, Vq, V);
            } else {
              readQuads(elementCount, element, localElement, component, q, U, sharedBuffer);
              contractTransposeX(q, localElement, sharedBuffer, B, Vp);
              writeDofs(element, component, q, Vp, V);
            }
          }
        }

      }
    }
  }
}

@kernel void grad(const CeedInt elementCount,
                  const bool transpose,
                  @restrict const CeedScalar *B,
                  @restrict const CeedScalar *Bx,
                  @restrict CeedScalar *V) {

  for (int elementOffset = 0; elementOffset < elementCount; elementOffset += ELEMENTS_PER_BLOCK; @outer) {
    @shared CeedScalar sharedBuffer[SHARED_BUFFER_SIZE];

    for (int localElement = 0; localElement < ELEMENTS_PER_BLOCK; ++localElement; @inner) {
      for (int q = 0; q < Q1D; ++q; @inner) {

        const int element = elementOffset + localElement;
        if (element < elementCount) {
          for (int component = 0; component < BASIS_COMPONENT_COUNT; ++component) {
            if (!transpose) {
              CeedScalar Vq;
              readDofs(element, localElement, component, q, U, sharedBuffer);
              contractX(q, localElement, sharedBuffer, Bx, Vq);
              writeQuads(elementCount, element, component, q, Vq, V);
            } else {
              CeedScalar Vp;
              readQuads(elementCount, element, localElement, component, q, U, sharedBuffer);
              contractTransposeX(q, localElement, sharedBuffer, Bx, Vp);
              writeDofs(element, component, q, Vp, V);
            }
          }
        }

      }
    }
  }
}

@kernel void weight(const CeedInt elementCount,
                    @restrict const CeedScalar *qWeights1D,
                    @restrict elementWeightArray W) {
  for (int elementOffset = 0; elementOffset < elementCount; elementOffset += ELEMENTS_PER_BLOCK; @outer) {
    for (int element = elementOffset; element < (elementOffset + ELEMENTS_PER_BLOCK); ++element; @outer) {
      for (int q = 0; q < Q1D; ++q; @inner) {
        W(q, element) = qWeights1D[q];
      }
    }
  }
}

);

#endif
