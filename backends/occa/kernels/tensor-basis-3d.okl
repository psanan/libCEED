// Copyright (c) 2019, Lawrence Livermore National Security, LLC.
// Produced at the Lawrence Livermore National Laboratory. LLNL-CODE-734707.
// All Rights reserved. See files LICENSE and NOTICE for details.
//
// This file is part of CEED, a collection of benchmarks, miniapps, software
// libraries and APIs for efficient high-order finite element and spectral
// element discretizations for exascale applications. For more information and
// source code availability see http://github.com/ceed.
//
// The CEED research is supported by the Exascale Computing Project 17-SC-20-SC,
// a collaborative effort of two U.S. Department of Energy organizations (Office
// of Science and the National Nuclear Security Administration) responsible for
// the planning and preparation of a capable exascale ecosystem, including
// software, applications, hardware, advanced system engineering and early
// testbed platforms, in support of the nation's exascale computing imperative.

#ifndef CEED_OCCA_KERNELS_TENSORBASIS3D_HEADER
#define CEED_OCCA_KERNELS_TENSORBASIS3D_HEADER

#include "header.hpp"


static const char *tensorBasis3DSource = STRINGIFY_SOURCE(

typedef CeedScalar* sharedBufferArray  @dim(Q1D, Q1D, ELEMENTS_PER_BLOCK);
typedef CeedScalar* batchedDofArray    @dim(P1D, P1D, P1D, BASIS_COMPONENT_COUNT, elementCount);
typedef CeedScalar* batchedQuadArray   @dim(Q1D, Q1D, Q1D, elementCount, BASIS_COMPONENT_COUNT, 3);
typedef CeedScalar* dofToQuadMap       @dim(P1D, Q1D);
typedef CeedScalar* elementWeightArray @dim(Q1D, Q1D, Q1D, elementCount);


//---[ Utility Methods ]----------------
inline void add(const CeedScalar *U, CeedScalar *V) {
  for (int q = 0; q < Q1D; q++) {
    V[q] += U[q];
  }
}

inline void readDofs(const int element,
                     const int component,
                     const int px,
                     const int py,
                     const batchedDofArray U,
                     CeedScalar *Up) {
  // Zero out extra entries
  for (int pz = 0; pz < P1D; ++pz) {
    Up[pz] = (
      (px < P1D) && (py < P1D)
      ? U(px, py, pz, component, element)
      : 0.0
    );
  }
  for (int q = P1D; q < Q1D; ++q) {
    Up[q] = 0.0;
  }
}

inline void writeDofs(const int element,
                      const int component,
                      const int px,
                      const int py,
                      const CeedScalar *Vp,
                      batchedDofArray V) {
  if ((px < P1D) && (py < P1D)) {
    for (int pz = 0; pz < P1D; ++pz) {
      V(px, py, pz, component, element) = Vp[pz];
    }
  }
}

inline void readQuads(const int elementCount,
                      const int element,
                      const int component,
                      const int qx,
                      const int qy,
                      const int dim,
                      batchedQuadArray U,
                      CeedScalar *Uq) {
  for (int qz = 0; qz < Q1D; ++qz) {
    Uq[qz] = U(qx, qy, qz, element, component, dim);
  }
}

inline void writeQuads(const int elementCount,
                       const int element,
                       const int component,
                       const int qx,
                       const int qy,
                       const int dim,
                       const CeedScalar *Vq,
                       batchedQuadArray V) {
  for (int qz = 0; qz < Q1D; ++qz) {
    V(qx, qy, qz, element, component, dim) = Vq[qz];
  }
}

inline void contractX(const int qx,
                      const int qy,
                      const int localElement,
                      sharedBufferArray sharedBuffer,
                      const dofToQuadMap B,
                      const CeedScalar *Uq,
                      CeedScalar *Vp) {
  for (int pz = 0; pz < P1D; ++pz) {
    sharedBuffer(qx, qy, localElement) = Uq[pz];
    Vp[pz] = 0.0;
    @barrier();
    for (int p = 0; p < P1D; ++p) {
      Vp[pz] += B(p, qx) * sharedBuffer(p, qy, localElement);
    }
    @barrier();
  }
}

inline void contractY(const int qx,
                      const int qy,
                      const int localElement,
                      sharedBufferArray sharedBuffer,
                      const dofToQuadMap B,
                      const CeedScalar *Uq,
                      CeedScalar *Vp) {
  for (int pz = 0; pz < P1D; ++pz) {
    sharedBuffer(qx, qy, localElement) = Uq[pz];
    Vp[pz] = 0.0;
    @barrier();
    for (int p = 0; p < P1D; ++p) {
      Vp[pz] += B(p, qy) * sharedBuffer(qx, p, localElement);
    }
    @barrier();
  }
}

inline void contractZ(const int qx,
                      const int qy,
                      const int localElement,
                      sharedBufferArray sharedBuffer,
                      const dofToQuadMap B,
                      const CeedScalar *Up,
                      CeedScalar *Vq) {
  for (int qz = 0; qz < Q1D; ++qz) {
    Vq[qz] = 0.0;
    for (int p = 0; p < P1D; ++p) {
      Vq[qz] += B(p, qz) * Up[p];
    }
  }
}

inline void contractTransposeX(const int px,
                               const int py,
                               const int localElement,
                               sharedBufferArray sharedBuffer,
                               const dofToQuadMap B,
                               const CeedScalar *Up,
                               CeedScalar *Vp) {
  for (int pz = 0; pz < P1D; ++pz) {
    sharedBuffer(px, py, localElement) = Up[pz];
    Vp[pz] = 0.0;
    @barrier();
    if (px < P1D) {
      for (int q = 0; q < Q1D; ++q) {
        Vp[pz] += B(px, q) * sharedBuffer(q, py, localElement);
      }
    }
    @barrier();
  }
}

inline void contractTransposeY(const int px,
                               const int py,
                               const int localElement,
                               sharedBufferArray sharedBuffer,
                               const dofToQuadMap B,
                               const CeedScalar *Up,
                               CeedScalar *Vp) {
  for (int pz = 0; pz < P1D; ++pz) {
    sharedBuffer(px, py, localElement) = Up[pz];
    Vp[pz] = 0.0;
    @barrier();
    if (py < P1D) {
      for (int q = 0; q < Q1D; ++q) {
        Vp[pz] += B(px, q) * sharedBuffer(px, q, localElement);
      }
    }
    @barrier();
  }
}

inline void contractTransposeZ(const int px,
                               const int py,
                               const int localElement,
                               sharedBufferArray sharedBuffer,
                               const dofToQuadMap B,
                               const CeedScalar *Uq,
                               CeedScalar *Vq) {
  for (int qz = 0; qz < Q1D; ++qz) {
    Vq[qz] = 0.0;
    if (qz < P1D) {
      for (int q = 0; q < Q1D; ++q) {
        Vq[qz] += B(qz, q) * Uq[q];
      }
    }
  }
}

//---[ Kernels ]------------------------
@kernel void interp(const CeedInt elementCount,
                    const bool transpose,
                    @restrict const CeedScalar *B,
                    @restrict const CeedScalar *U,
                    @restrict CeedScalar *V) {

  for (int elementOffset = 0; elementOffset < elementCount; elementOffset += ELEMENTS_PER_BLOCK; @outer) {
    @shared CeedScalar sharedBuffer[SHARED_BUFFER_SIZE];

    for (int localElement = 0; localElement < ELEMENTS_PER_BLOCK; ++localElement; @inner) {
      const int element = elementOffset + localElement;
      for (int qy = 0; qy < Q1D; ++qy; @inner) {
        for (int qx = 0; qx < Q1D; ++qx; @inner) {

          if (element < elementCount) {
            for (int component = 0; component < BASIS_COMPONENT_COUNT; ++component) {
              CeedScalar r1, r2;
              if (!transpose) {
                readDofs(element, component, qx, qy, U, r1);
                contractX(qx, qy, localElement, sharedBuffer, B, r1, r2);
                contractY(qx, qy, localElement, sharedBuffer, B, r2, r1);
                writeQuads(elementCount, element, component, qx, qy, 0, r1, V);
              } else {
                readQuads(elementCount, element, component, qx, qy, 0, U, r1);
                contractTransposeY(qx, qy, localElement, sharedBuffer, B, r1, r2);
                contractTransposeX(qx, qy, localElement, sharedBuffer, B, r2, r1);
                writeDofs(element, component, qx, qy, r1, V);
              }
            }
          }

        }
      }
    }
  }
}

@kernel void grad(const CeedInt elementCount,
                  const bool transpose,
                  @restrict const CeedScalar *B,
                  @restrict const CeedScalar *Bx,
                  @restrict const CeedScalar *U,
                  @restrict CeedScalar *V) {

  for (int elementOffset = 0; elementOffset < elementCount; elementOffset += ELEMENTS_PER_BLOCK; @outer) {
    @shared CeedScalar sharedBuffer[SHARED_BUFFER_SIZE];

    for (int localElement = 0; localElement < ELEMENTS_PER_BLOCK; ++localElement; @inner) {
      const int element = elementOffset + localElement;
      for (int qy = 0; qy < Q1D; ++qy; @inner) {
        for (int qx = 0; qx < Q1D; ++qx; @inner) {

          if (element < elementCount) {
            for (int component = 0; component < BASIS_COMPONENT_COUNT; ++component) {
              CeedScalar r1, r2, r3;
              if (!transpose) {
                readDofs(element, component, qx, qy, U, r1);
                contractX(qx, qy, localElement, sharedBuffer, Bx, r1, r2);
                contractY(qx, qy, localElement, sharedBuffer, B, r2, r3);
                writeQuads(elementCount, element, component, qx, qy, 0, r3, V);
                contractX(qx, qy, localElement, sharedBuffer, B, r1, r2);
                contractY(qx, qy, localElement, sharedBuffer, Bx, r2, r3);
                writeQuads(elementCount, element, component, qx, qy, 1, r3, V);
              } else {
                readQuads(elementCount, element, component, qx, qy, 0, U, r1);
                contractTransposeY(qx, qy, localElement, sharedBuffer, B, r1, r2);
                contractTransposeX(qx, qy, localElement, sharedBuffer, Bx, r2, r3);
                readQuads(elementCount, element, component, qx, qy, 1, U, r1);
                contractTransposeY(qx, qy, localElement, sharedBuffer, Bx, r1, r2);
                contractTransposeX(qx, qy, localElement, sharedBuffer, B, r2, r1);
                writeDofs(element, component, qx, qy, r1, r1 + r3);
              }
            }
          }

        }
      }
    }
  }
}

@kernel void weight(const CeedInt elementCount,
                    @restrict const CeedScalar *qWeights1D,
                    @restrict elementWeightArray W) {
  for (int element = 0; element < elementCount; ++element; @outer) {
    for (int qz = 0; qz < Q1D; ++qz; @inner) {
      for (int qy = 0; qy < Q1D; ++qy; @inner) {
        for (int qx = 0; qx < Q1D; ++qx; @inner) {
          W(qx, qy, qz, element) = qWeights1D[qx] * qWeights1D[qy] * qWeights1D[qz];
        }
      }
    }
  }
}

);

#endif
